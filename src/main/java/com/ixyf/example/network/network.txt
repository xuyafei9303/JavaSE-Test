网络相关：
    OSI七层网络模型
        应用层                 访问网络的服务接口：Telnet、FTP、HTTP、SNMP、DNS
        表示层                 数据格式转换和表示：数据加解密、数据编解码、数据压缩和解压
        会话层                 建立连接并访问验证和会话管理：登陆验证、断点续传、数据粘包分包
        传输层                 定义了传输数据的协议和端口号：TCP、UDP
        网络层                 IP地址的封装和解析，路由器、交换机、防火墙
        数据链路层              MAC地址解析和封装，数据帧：网卡、网桥、交换机
        物理层                 定义物理设备标准，比特流：数模转换和模数转换

    TCP/IP四层网络模型
        TCP/IP不是指TCP和IP这两个协议的合称，而是指因特网的整个TCP/IP协议族
        应用层                 服务及应用程序：Telnet、FTP、HTTP、SNMP、DNS
        传输层                 确认数据传输及错误处理：TCP、UDP
        网络层                 服务数据的传输、路由及地址的选择：IP、ARP地址解析协议
        网络接口层              定义物理网络连接的通信协议：Ethernet、FDDI、ATM

    TCP三次握手/四次挥手
        TCP数据遭传输之前首先需要建立连接，建立连接需要三次通信，一般称为三次挥手，断开连接要进行四次通信，一般称为四次挥手

        TCP的数据包结构：
        - 源端口号 16位           和源主机的IP地址一起标识源主机的一个应用进程
        - 目的端口号 16位          和源主机的IP地址一起标识目的主机的一个应用进程
        - 顺序号seq 32位          标识从TCP源端向TCP目的端发送的数据字节流，表示这个报文段中的第一个数据字节的顺序号。TCP用顺序号对每个字节进行计数，序号是32bit的无符号数，序列号达到2的32次方 - 1，
                                就又从0开始。在建立一个新的连接的时候，SYN标志为1，顺序号字段包含由这个主机选择的该连接的初始顺序号ISN（Initial Sequence Number）
        - 确认号ack 32位          存储发送确认的一端所期望收到的下一个顺序号。确认序列号是上次已成功收到的数据字节顺序号+1.只有ACK标志位为1时确认顺序号字段才有效。TCP为应用层提供全双工服务，这意味着数据
                                能在两个方向上独立进行传输。因此，连接的每一端都必须保持每个方向上的传输数据顺序号
        - TCP报头长度 4位         存储报头中头部数据的长度，他指明了数据从哪里开始。需要这个值是因为任选字段的长度是可变的，该字段占4个字节，因此TCP最多有60字节的首部，但没有任选字段，正常的长度是20字节
        - 保留位 6位              数据保留位，目前必须被设置为0
        - 控制位 6位              （control flags）在TCP报头中有6个标志比特，他们中的多个可被同时设置为1
            关于控制位的说明
            1           URG         为1时表示紧急指针有效，为0时忽略紧急指针的值
            2           ACK         为1时表示确认号有效，为0时表示在报文中不包含确认信息，忽略确认号字段
            3           PSH         为1表示带有PSH标志的数据，表示接收方应该尽快将这个报文段交给应用层，而不用等待缓冲区装满
            4           RST         用于复位由于主机崩溃或其他原因而出错的连接，还可以拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个RST为1的报文，那么一定发生了某种问题
            5           SYN         同步序号，为1表示连接请求，用于建立连接和使顺序号同步
            6           FIN         用于释放连接，为1时代表发送方已经没有数据要送达了，即关闭本方数据流
        - 窗口大小 16位          数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。窗口大小是16bit的字段，因而窗口最大为65535字节
        - 校验和 16位            此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位字符计算所得。是一个强制性字段，一定是由发送端计算和存储的，并由接收端验证
        - 紧急指针 16位          只有在URG标志置为1时紧急指针才有效，这时告诉TCP该条数据需要紧急发送
        - 选项                  最常见的可选字段是最长报文大小，又叫做MSS（Maximum Segment Size）。每个连接方通常都在通信的第一个报文段（未建立连接而设置SYN标志的那个段）
                                中指明这个选项，表明该TCP连接能接收的最大长度的报文段。选项长度不一定是32字节的整数，因此需要填充位，使得报头长度为整数字段
        - 数据                  TCP报文中的数据部分是可选的。在一个连接建立和连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，则也使用没有任何数据的首部确认收到的数据。在处理超时的许多情况也会发送不带数据的报文段

    TCP三次握手的过程：
        1. 客户端发送SYN（seq=x）报文给服务器端，进入SYN_SEND状态
        2. 服务器端收到SYN报文，回应一个SYN（seq=y）和ACK（ack=x+1）报文，进入SYN_RECV状态
        3. 客户端收到服务器端的SYN报文，回应一个ACK（ack=y+1）报文，进入Established状态
        至此，TCP客户端和服务器端成功建立连接，可以开始传输数据了。

    TCP中的四次挥手：
        TCP在连接的时候要进行三次握手，但是在断开连接的时候要进行四次挥手，这是由于TCP的半关闭造成的。因为TCP连接是全双工的（即数据可在两个方向上独立传输），所以在进行关闭时对每个方向
        都要进行关闭，这种单方向的关闭叫做半关闭。在一方完成他的数据发送任务时，就发送一个FIN来向另一方通告将要终止这个方向的连接。
        TCP断开连接既可以是由客户端发起，也可以是服务器端发起：如果由客户端发起断开连接操作，则称客户端主动断开连接；如果由服务器端发起断开连接操作，则称服务器端主动断开连接
        四次挥手的过程：
            1. 客户端应用进程调用断开连接的请求，向服务器端发送一个终止标志位FIN=1，seq=u的消息，表示在客户端关闭链路前要发送的数据以及发送完毕，可以开始关闭链路操作，并请求服务器端确认客户端关闭客户端到服务器的链路操作，此时客户端处于FIN-WAIT-1状态
            2. 服务器在收到这个FIN消息后返回一个ACK=1,ack=u+1，seq=v的消息给客户端，表示接收到客户端断开链路的操作请求，这时TCP服务器进程通知高层应用进程释放客户端到服务器端的链路，服务器处于CLOSE-WAIT状态，即半关闭状态。客户端收到消息后处于FIN-WAIT-2状态
            3. 服务器端在关闭链路前将需要发送给客户端的消息发送给客户端，等待该数据发送完成后，发送一个终止标志位FIN=1,ACK=1,seq=w,ack=u+1的消息给客户端，表示关闭链路钱服务器需要向客户端发送的消息已经发生完毕，
                请求客户端确认关闭从服务器到客户端的链路操作，此时服务器端处于LAST-ACK的状态，等待客户端最终断开链路
            4. 客户端在接受到这个最终FIN消息后，发送一个ACK=1，seq=u+1，ack=w+1的消息给服务器端，表示接受到服务器端的断开连接请求并准备断开服务器端到客户端的链路。此时客户端处于TIM-WAIT状态，TCP连接还没有释放，然后经过等待计时（2MSL）设置的超时时间后，客户端进入CLOSE状态
        关于Time-wait状态(2MSL)一些理解：
            这也是个面试题。
            假如说最后一次的ACK丢失了，server将会重新发FIN，client必须维护TCP状态信息以便可以重发最后的ACK，否则将会发生RST（如果连接错误或者其他崩溃的原因会出现RST，如果RST=1，那么一定出问题了）。
            TCP实现必须可靠的终止连接的两个方向，所以client必须进入TIME-WAIT状态。MSL是Maximum Segment Lifetime,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
            RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。
            2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间。
            等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。
            在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。
            当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口
            如果TIME_WAIT状态保持时间不足够长，第一个连接就正常终止了。第二个拥有相同五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP事先必须防止某个连接的重复报文在连接终止后出现，
            所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向的上的TCP报文要么完全响应完毕，要么被丢弃。建立第二个连接的时候，不会混淆。
            之所以设计这个2MSL是为了：
            1. 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）
            2. 可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。
               所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。

    HTTP的原理
        HTTP是一个无状态协议，无状态是指在客户端和服务器之间不需要建立持久的连接，在一个客户端向服务端发出请求且服务器收到该请求并返回响应后，本次通信结束，HTTP连接被关闭，服务器不再保留连接的相关信息
        HTTP遵循请求（Request）/（Response）模型，客户端向服务器发送请求，服务器处理请求并返回适当的应答。

        HTTP的传输流程
            1. 地址解析：地址解析通过域名系统DNS解析服务器域名从而获得主机的IP地址。例如：http://localhost.com:8080/index.html，则可以从中解析出如下部分：
                * 协议名：HTTP
                * 主机名：localhost:com
                * 端口：8080
                * 对象路径：/index.html
            2. 封装HTTP数据包：解析协议名、主机名、端口、对象路径等并结合本机自己的信息封装成一个HTTP请求数据包
            3. 封装TCP包：将HTTP请求数据包进一步封装成TCP数据包
            4. 建立TCP连接：基于TCP的三次握手机制建立TCP连接
            5. 客户端发送请求：在建立连接后，客户端发送一个请求给服务器
            6. 服务器响应：服务器在接收到请求后，结合业务逻辑进行数据处理，然后向客户端返回相应的响应信息。在响应信息中包含状态行、协议版本号、成功或错误的代码、消息体等等内容
            7. 服务器关闭TCP连接：服务器在向浏览器发送请求响应数据后关闭TCP连接。但如果浏览器或者服务器在消息头中加入了Connection：keep-alive，则TCP连接在请求响应数据发送后仍然保持连接状态
               ，在下一次请求中浏览器可以继续使用相同的连接发送请求。采用keep-alive方式不但减少了请求响应的时间，还节约了网络带宽和系统资源

            HTTP中的常见状态码
            '20x'格式的状态码表示成功
            '30x'格式的状态码表示网络重定向
            '40x'格式的状态码表示客户端请求错误
            '50x'格式的状态码表示服务器错误

            常用的如下：
            200             OK（成功），表示服务器已成功接收客户端请求并返回客户端所请求的最终结果
            202             Accepted（已创建），表示服务器已经接收了请求，但是还没有处理，最终是否处理还不确定
            204             No Content（无内容），服务器成功处理了请求，但没有返回任何实体内容，可能会返回新的头部元信息

            301             Moved Permanently（永久性重定向），客户端请求的网页已经移动到新的位置，当连接发生变化时，返回301代码告诉客户端链接的变化，客户端保存新的连接，并向新的连接发出请求，返回结果
            302             Found（临时性重定向），表示请求的资源被分配了新的URL，希望本次访问请求新的URL.301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）
            303             See Other（查看其他位置），表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源.302与303的区别：后者明确表示客户端应当采用GET方式获取资源
            304             Not Modified（未修改），表示客户端发送附带条件（指采用GET方法的请求报文中含有if-Match、if-Modified-Since、if-None-Match、if-Range、if-Unmodified-Since中任一部分）的请求，服务端允许访问资源，但是请求为满足条件的情况下返回该状态码

            400             Bad Request（错误请求），表示请求报文中存在语法错误
            401             Unauthorized（未授权），未经许可，需要通过HTTP认证通过
            403             ForBidden（禁止访问），服务器拒绝该次访问，访问权限出现问题
            404             NotFound（未找到），表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝但不想给拒绝原因时使用
            405             Method Not Allowed（不允许使用该方法），客户端试图使用一个本资源不支持的HTTP方法时返回此状态

            500             Internal Server Error（内部服务器错误），服务器在之心请求时发生了错误，导致无法完成客户端当前的请求
            503             Service Unavailable（服务不可用），服务器由于临时的服务器过载或者是维护，无法解决当前的请求


    HTTPS的原理
        HTTPS是以安全为目标的HTTP通道，他在HTTP中加入SSL层以提高数据传输的安全性。HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并对浏览器和服务器之间的通信进行数据加密，以保障数据传输的安全性，端口一般为443
        HTTPS加密流程如下：
            1. 发起请求：客户端在通过TCP和服务器建立连接后（默认443端口），发出一个请求证书的消息给服务器，在该请求消息里包含自己可实现的算法列表和其他需要的信息
            2. 证书返回：服务器端在收到消息后回应客户端并返回证书，在证书中包含服务器信息、域名、申请证书的公司、公钥、数据加密算法等
            3. 证书验证：客户端收到证书后，判断证书签发机构是否正确，并使用该签发机构的公钥确认签名是否有效，客户端还会确保在证书列出的域名为正在连接的域名。如果客户端验证证书有效，则生成对称秘钥，并使用公钥将对称秘钥加密
            4. 秘钥交换：客户端将加密后的对称秘钥发送给服务器，服务器在接收到对称秘钥后使用私钥解密
            5. 数据传输：经过以上步骤，客户端和服务端就完成了秘钥对的交换，在之后的数据传输过程中，客户端和服务端就可以基于对称加密（加密和解密使用相同秘钥的加密算法）将数据加密后在网络上传输，保证了网络数据传输的安全性

    Nginx反向代理和负载均衡
        正向代理：正向代理类似于一个跳板机，代理访问外部资源。比如国内访问谷歌，直接访问是404，我们可以通过正向代理服务器，请求发到代理服务器，代理服务器再去访问谷歌，谷歌返回数据给代理服务器，代理服务器再返回给我们数据
                作用：
                    * 访问原来无法访问的资源，比如Google
                    * 可以做缓存，加速访问资源
                    * 对客户端访问授权，上网进行认证
                    * 记录用户访问记录之类，做上网行为管理，对外隐藏用户信息
        反向代理：以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外表现就是一个服务器
                作用：
                    * 保证内网的安全，阻止web攻击，大型网站通常将反向代理作为公网访问地址,web服务器是内网
                    * 负载均衡，通过反向代理来优化网站的均衡
        总结：
            正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端
            反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端
        1. upstream_module
            负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查。upstream允许Nginx定义一组或多组节点服务器，在使用时可以通过proxy_pass代理方式把网站的请求发送到事先定义后的对应upstream组的名字上
            具体定义如下：
                upstream restLVSServer {
                    server  192.168.100.1:9000 weight=5;
                    server  192.168.100.2:9000;
                    server  example.com:9000 max_fails=2 fail_timeout=10s backup;
                }
                weight：服务器权重
                max_fails：Nginx尝试连接后端服务器的最大失败次数，如果失败时大于max_fails，则认为该服务器不可用
                fail_timeout：max_fails和fail_timeout一般会关联使用，如果某台服务器在fail_timeout时间内出现了max_fails次连接失败，那么Nginx会认为其已经挂掉，从而在fail_timeout时间后不再去请求他
                              fail_timeout默认是10s，max_fail默认是1，即在默认情况下，只要发生错误就认为服务器挂了，如果将max_fails设置为0，则表示取消这项检查
                backup：表示当前服务器是备用服务器，只有其他非backup后端服务器都挂掉或很忙时，才会分配请求到backup服务器
                down：标志服务器永远不可用
        2. proxy_pass
            可以将请求转发到另一台服务器，在实际的反向代理工作中，会通过location功能匹配指定的URI，然后把接收到的服务匹配URI的请求通过proxy_pass抛给定义好的upstream节点池。
                location /location/ {
                    proxy_pass http://192.168.100.111:9000/download/vedio/;
                }
                上面代码定义了一个download的反向代理，在客户端请求/download/时，nginx会将具体的请求转发给proxy_pass配置的地址处理请求，这里的地址就是proxy_pass里面的地址


