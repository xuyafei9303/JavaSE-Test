线程池：
    用于管理线程组及其状态，以便Java虚拟机更好的利用cpu资源
    工作原理：
        jvm先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果正在运行的线程数量超过了最大线程数量（用户设置的线程池大小），
        则超出数量的线程排队等候，在有任务执行完毕后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行

    线程复用：
        在Java中。每个thread都有一个start方法，在线程调用start方法启动线程的时候，Java虚拟机会调用该类的run方法。在thread类的run方法其实是调用了runnable对象的run方法，
        因此可以继承thread类，在start方法中不断循环调用传递进来的runnable对象，程序就会不断的执行run方法中的代码，可以将在循环方法中不断获取的runnable对象存放在queue中，
        当前线程在获取下一个runnable对象之前可以是阻塞的，这样既有效控制正在执行的线程个数，也能保证系统中正在等待执行的其他线程有序执行，这样就简单实现了一个线程池。

    线程池的核心组件和核心类：
        线程池管理器：用于创建线程池
        工作线程：线程池中执行具体任务的线程
        任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度
        任务队列：存放待处理的任务，新的任务将会不断的加入队列中，执行完成的任务将被从队列中移除

    Java中的线程池通过Executor框架来实现,核心类如下:
        Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable、Future、FutureTask等

        ThreadPoolExecutor构造函数具体参数如下：
            corePoolSize                线程池中核心线程数
            maximumPoolSize             线程池中最大线程的数量
            keepAliveTime               当前线程数量超过corePoolSize时，空闲线程的存活时间
            unit                        keepAliveTime的时间单位
            workQueue                   任务队列，被提交但尚未被执行的任务存放的地方
            threadFactory               线程工厂，用于创建线程，可使用默认的线程工厂或者自定义的线程工厂
            handler                     由于任务过多或者其他原因导致的线程池无法处理任务时的拒绝策略

    工作流程：
        1.如果正在运行的线程数量小于corePoolSize，线程池就会立刻创建线程并执行该线程任务
        2.如果正在运行的线程数量大于等于corePoolSize，该任务就将被放入阻塞队列中
        3.在阻塞队列已满且正在运行的线程数量小于maximumPoolSize时，线程池会创建非核心线程立刻执行该线程任务
        4.在阻塞队列已满且正在运行的线程数量大于等于maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常
        5.在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取出下一个线程任务继续执行
        6.在线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线程任务都执行完毕后，线程池会收缩到corePoolSize大小

    线程池的拒绝策略：
        若线程池中的核心线程数量被用完且阻塞队列已排满，则此时线程池的线程资源已耗尽，线程池将没有足够的线程资源执行新的任务
        JDK内置的拒绝策略如下：
            1.AbortPolicy               直接抛出异常，阻止线程正常运行
            2.CallerRunsPolicy          如果被丢弃的线程任务未关闭，则执行该线程任务，不会真的丢任务
            3.DiscardOldestPolicy       移除线程队列中最早的一个线程任务，并尝试提交当前任务
            4.DiscardPolicy             丢弃当前的线程任务而不做任何处理，如果系统允许在资源不足的情况下丢弃部分任务，则这将是保障系统安全，稳定的一种很好的方案
            5.自定义策略                  以上四种均实现了RejectedExecutionHandler接口，若无满意实际需求，则用户可以自己扩展RejectedExecutionHandler接口来实现拒绝策略，并捕获异常来实现拒绝策略

    五种常用的线程池（均实现ExecutorService）
        newCachedThreadPool             可缓存的线程池
        newFixedThreadPool              固定大小的线程池
        newScheduledThreadPool          可做任务调度的线程池
        newSingleThreadExecutor         单个线程的线程池
        newWorkStealingPool             足够大小的线程池，JDK1.8新增

    线程的生命周期：
        新建                             NEW（为线程分配内存并初始化其成员变量的值）
        就绪                             Runnable
        运行                             Running
        阻塞                             Blocked
            阻塞分三种：
                1.等待阻塞：在运行状态的线程调用wait方法时，jvm会把该线程放入等待队列，转为阻塞状态
                2.同步阻塞：在运行状态的线程尝试获取正在被其他线程占用的对象同步锁时，jvm会把该线程放入锁池（Lock Pool），转为阻塞状态
                3.其他阻塞：运行状态的线程在执行Thread.sleep(long ms)、Thread.join()或者发出IO请求时，jvm会把该线程转为阻塞状态，直到sleep超时，join等待线程终止或超时，或者IO处理完毕，才转为可运行状态
        死亡                             Dead
            死亡分三种：
                1.线程正常退出：run方法或call方法执行完成
                2.线程异常退出：运行中的线程抛出一个error或者未捕获的exception，线程异常退出
                3.手动结束：调用线程对象的stop方法手动结束运行中的线程（该方法会瞬间释放线程占用的同步对象锁，导致锁混乱和死锁，不推荐使用）
    线程状态的转换流程：
        1.调用new方法新建一个线程，这时候线程处于新建状态
        2.调用start方法启动一个线程，这时候线程处于就绪状态
        3.处于就绪状态的线程等待线程获取CPU资源，在等待其获取资源后会执行run方法进行运行状态
        4.正在运行的线程在调用了yield方法或失去处理器资源后，会再次进入就绪状态
        5.正在执行的线程在执行了sleep方法、IO阻塞、等待同步锁、等待通知、调用suspend方法等操作后，会挂起并进入阻塞状态，进入blocked池
        6.阻塞状态的线程由于出现sleep时间已到、IO方法返回、获得同步锁、收到通知、调用resume方法等情况，会再次进入就绪状态，等待CPU时间片的轮询，该线程在获取cpu资源后，会再次进入运行状态
        7.处于运行状态的线程，在调用run方法或call方法正常执行完成，调用stop方法停止线程或者程序执行错误导致异常退出，会进入死亡状态
    线程的基本方法：
        1.线程等待：wait()，调用wait方法的线程会进入WAITING状态，只有等到其他线程的通知或者被中断后才会返回。在调用wait方法后，会释放对象的锁，因此wait方法一般用于同步方法或者同步代码块
        2.线程睡眠：sleep()，调用sleep方法会导致当前线程休眠。与wait不同的是，sleep不会释放当前占有的锁，会导致TIMED-WAITING状态，而wait方法会导致当前线程进入WAITING状态
        3.线程让步：yield()，调用yield会使当前线程让出（释放）CPU执行时间片，与其他线程一起重新竞争CPU时间片。一般情况下，优先级高的线程更有可能竞争到CPU时间片，但不是绝对的
        4.线程中断：interrupt()，用于向线程发送一个终止通知信号，会影响该线程内部的一个中断标识位，线程本身并不会因为调用了interrupt方法而改变状态（阻塞、终止等）。状态的具体变化需要等待接收到中断标识的程序的最终处理结果来判定
            4-1 调用interrupt方法并不会中断一个正在运行的线程，也就是说处于running状态的线程并不会因为调用了interrupt方法而终止，仅仅是改变了内部维护的中断标识位而已。
            4-2 若因为调用sleep方法而是线程处于TIMED-WAITING状态，则这时调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WAITING状态
            4-3 许多声明抛出InterruptedException的方法如Thread.sleep(long mills)，在抛出异常前都会清除中断标识位，所以在抛出异常后调用isInterrupted方法将会返回false
            4-4 中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如，在在想终止一个线程时，可以先调用该线程的interrupt方法，然后在线程的run方法中根据该线程isInterrupt方法，然后在线程的run方法中根据该线程isInterrupted方法的返回状态值安全终止线程
            注意：
                interrupted()测试的是当前线程(current thread)的中断状态，且这个方法会清除中断状态。是静态方法（它测试的是当前线程的中断状态）
                isInterrupted()测试的是调用该方法的对象所表示的线程，且这个方法不会清除中断状态。是实例方法（它测试的是实例对象所表示的线程的中断状态）
        5.线程加入：join()，用于等待其他线程终止，如果在当前线程中调用一个线程的join方法，则当前线程会转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态转为就绪状态，等待获取CPU的使用权。很多时候，主线程生成很多子线程，需要子线程返回执行结果并收集处理再推出，这时候就可以使用join
        6.线程唤醒：notify()，Object类有一个notify方法,用于唤醒在此对象监视器上等待的一个线程,如果所有线程都在此对象上等待,则会唤醒其中一个线程,唤醒时是任意选择的.类似的方法还有notifyAll()，用于唤醒等待的所有线程
        7.后台守护线程：setDaemon()，用于定义一个守护线程，也叫做服务线程，该线程是后台线程。后台线程为用户线程提供公共服务，在没有用户线程可服务时自动离开。守护线程依赖于jvm，与jvm同生死

    sleep和wait的区别：
        sleep属于Thread类，wait方法属于Object类
        sleep方法暂停执行指定的时间，让出CPU给其他线程，使其监控状态依然保持，给指定的时间过后又会自动恢复运行状态
        在调用sleep的过程中，线程不会释放对象锁
        在调用wait时，线程会放弃对象锁，进入等待次对象的等待锁池，只有针对此对象调用notify后，该线程才能进入对象锁池准备获取对象锁，并进入运行状态
    start和run的区别：
        start用于启动线程，真正实现了多线程运行，在调用了线程的start后，线程会在后台运行，无需等待run方法体的代码执行完毕，就可以继续执行下面的代码
        在通过调用Thread类的start启动一个线程时，此线程处于就绪状态，并没有运行
        run方法也叫线程体，包含了要执行的线程的逻辑代码，在调用了run方法后，线程会进入运行状态，开始运行run方法中的代码。在run方法运行结束后，该线程终止，CPU再次调度其他线程。

    终止线程的4种方式：
        1.正常运行结束，线程体执行完成，线程自动结束
        2.使用退出标志退出线程
            有些线程是后台线程，需要长时间运行，只有在系统满足某些特殊条件后，才能退出这些线程，这时候可以使用一个变量来控制循环，比如设置一个boolean类型的标志，并通过设置这个标志位false或true来控制while循环是否退出
        3.使用interrupt方法终止线程
            3-1 线程处于阻塞状态。例如使用了sleep，调用锁的wait或者调用socket的receiver、accept等方法时，会使线程处于阻塞状态。在调用线程的interrupt方法时，会抛出InterruptException异常。通过在代码中捕获这个异常，然后通过break跳出状态监测循环，结束这个线程的执行。
            3-2 线程未处于阻塞状态。此时，使用isInterrupt方法判断线程的中断标志位来退出循环。在调用interrupt时，中断标志会被设置为true，此时并不能立刻退出线程，而是需要执行线程终止前的资源释放操作，等待资源释放完毕之后方可安全退出该线程。
        4.使用stop终止线程：不安全
            可以直接使用Thread.stop来终止线程，但这是很危险的，就像突然关闭计算机电源，而不是正常关机是一个道理，可能产生不可预料的后果。
            在调用了stop后，该线程的子线程会抛出ThreadDeathError错误，并且释放子线程持有的所有锁。

